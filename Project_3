#lang racket
; Counts the number of elements in a given list
(define (count lst)
  (cond
    ; If the list is empty, we return 0
    [(empty? lst) 0]
    ; Otherwise we recursively call count again
    ; and add the results together
    [else (+ (count (cdr lst)) 1)]
    )
  )

; Uses the Euclidian Metric to calculate the distance
; between two points
(define (distance vertex1 vertex2)
  (cond
    ; If either of the verticies are null, we return 0
    [(or (empty? vertex1) (empty? vertex2)) 0]
    ; Otherwise we calculate their distance using the following formula:
    ;
    ; Let vertext1 = (x1,x2) and vertex2=(y1,y2). Then
    ; distance(vertex1, vertex2) =
    ; distance((x1,x2),(y1,y2)) =
    ; sqrt[(y1-x1)^2+(y2-x2)^2]
    [else (sqrt (+ (sqr (- (car vertex2) (car vertex1))) (sqr (- (cadr vertex2) (cadr vertex1)))))]
    )
  )
; Geneates a list of values 1 to n
(define (generateAscendingList from to)
  (if (> from to)
      '()
      (cons from (generateAscendingList (+ from 1) to)))
  )

; Generates all possible tours from the specified input list
(define (genTours n)
  (startsWith 1 (permutationsOf (generateAscendingList 1 n)))
  )

; This will calculate the overall length ("score") of a specified tour
(define (score verticies tour)
  (cond
    ; If there's only one element left in the tour, then the last distance
    ; that we must calculate is the distance between the starting node
    ; and one at the end of the tour
    [(eqv? 1 (count tour))
     (distance (elementAt verticies (car tour))
               (elementAt verticies 1))]
    ; Otherwise, we calculate the distance from the two consecutive nodes
    ; in the tour, then add that result recursively to the distance of
    ; the next two consecutive nodes in the tour
    [else
     (+ (distance (elementAt verticies (car tour))
                  (elementAt verticies (cadr tour)))
        (score verticies (cdr tour)))])
  )

; Calculates the shortest tour of all possible tours from the specified
; list
(define (etsp lst)
  ; We want to return the element of the list of tours that matches the shortest
  ; tour in the list, so we want to get the element whose index is equal to the
  ; index of the minimum value of the list of the lengths of all of the tours
  ;
  ; In other words:
  ; let elementAt = f(x),
  ; let genTours = g(x),
  ; let count = h(x),
  ; let indexOf = i(x),
  ; let tourLengths = j(x),
  ; let flattenLeft = k(x),
  ; let car=l(x)
  ; 
  ; then we have the following composition:
  ;
  ; etsp(x) = f(g(h(x)), i(j(x), k(~lambda(l(j(x)))), j(x), 1))
  (elementAt
   (genTours (count lst))
   (indexOf
    (tourLengths lst)
    (flattenLeft
     (lambda (e a) (if (< e a) e a))
     (car (tourLengths lst))
                 (tourLengths lst)) 1))
  )

; Returns the index of the specified list that equals the specified value
(define (indexOf lst n index)
  (cond
    [(empty? lst) -1]
    [(eqv? n (car lst)) index]
    [else (indexOf (cdr lst) n (add1 index))])
  )
  
; Returns the list of tour lengths
(define (tourLengths lst)
  ; We apply the specified lambda function to every element in the list
  (mapOnto
   ; We curry each element together with this lambda for each unique tour
   (curry
    ; Then we return the score of the tour
    (lambda (x) (score lst x)))
   ; And finally, we generate the tours to be applied through the aforementioned
   ; process by calling genTours with the size of the list
   (genTours (count lst)))
  )

; Returns the element at the specified index of a list
;
; Note: Does NOT use java-like indicies.
;
; (elementAt '(1 2 3 4) 3) will return 3
(define (elementAt lst n)
  (cond
    [(empty? lst) lst]
    ; If our counter is equal to 1, we're done
    [(eqv? n 1) (car lst)]
    ; Otherwise, we recursively call elementAt with the
    ; rest of the list
    [else (elementAt (cdr lst) (- n 1))]
    )
  )

; Returns all possible permutations of a given list
(define (permutationsOf lst)
  (cond
    ; If the size of our list is 1, then there's only one possible permutation
    [(eqv? 1 (count lst)) (list (list lst))]
    ; If the size of our list is 2, then the only possible
    ; permutations are (x,y) and (y,x)
    [(eqv? 2 (count lst))
     (list
      (list (car lst) (cadr lst))
      (list (cadr lst) (car lst)))]
    ; Otherwise,
    [else
     ; First we apply the append operation to an empty list and flatten the
     ; specified list from the inner most pair (i.e. apply append from right-to-left)
     (flattenRight append '()
                   ; Then we want to apply the specified lambda expression to each
                   ; element of the list
                   (mapOnto (lambda (x)
                              ; In the lambda, we want to map the function (curry cons x)
                              ; to the list generated by recursively calling this function
                              ; again to produce our list of permutations.
                              (mapOnto (curry cons x)
                                       ; The function (curry cons x) is saying to apply
                                       ; the function cons to every element of the list
                                       ; that follows its declaration. So, for example if
                                       ; you did (curry cons 5) '(1 2 3), then the result
                                       ; would be '(5 1 2 3)
                                       ;
                                       ; Another, easier to understand example is if you did
                                       ; (curry + 1 2 3 4), this is the same as saying
                                       ; (((((curry +) 1) 2) 3) 4), which yields
                                       ; (((1+2)+3)+4)=10
                                       ; i.e.
                                       ; (1+2)=3
                                       ; (3+3)=6
                                       ; (6+4)=10
                                       ;
                                       ; Note that the last argument here passes the specified
                                       ; list into the lambda expression
                                       (permutationsOf (removeFrom x lst '())))) lst))])
  )

; Recursively applies the specified function to each element in the specified list
;
; Note that the specified function must accept one argument
(define (mapOnto func lst)
  (if (empty? lst)
      '()
      (cons (func (car lst)) (mapOnto func (cdr lst))))
  )

; Recursively flattens the specified list into the specified
; initial value by applying the specified function in
; left-to-right order
;
; Note that the specified function must accept two arguments
(define (flattenLeft func init lst)
  (cond
    ; In the base case, return the initial value
    [(empty? lst) init]
    [else
     ; Now flatten the current item in the list into the accumulator (init)
     ; Then pass that to the next recursive call as the new init
     (flattenLeft func
                  (func (car lst) init) ; Our new init
                  (cdr lst))])
  )

; Recursively flattens the specified list into the specified
; initial value by applying the specified function in
; right-to-left order
;
; Note that the specified function must accept two arguments
(define (flattenRight func init lst)
  (cond
    ; In our base case, if the list is empty, return the initial value
    [(empty? lst) init]
    [else
     ; Now, since we want to begin at the end of the list or the
     ; inner most pair, we must use the parenthetical order of operations
     ; to ensure that the inner most items get flattened first
     (func (car lst)
           (flattenRight func
                         init
                         (cdr lst)))])
  )

; Removes first occurence of the specified element from the list
(define (removeFrom x lst accumulatedList)
  (cond
    ; If the specified list is empty, return the accumlatedList
    [(empty? lst) accumulatedList]
    [else
     ; Otherwise, we first check to see if the first value in the list is the one
     ; that we want to remove.
     ; If so, then append the rest of the list to the accumulatedList and we're done
     (cond
       [(equal? x (car lst)) (append accumulatedList (cdr lst))]
       ; Otherwise, append the first element of the list to the accumulatedList,
       ; then append that to the result of recursively calling removeFrom
       [else
        (removeFrom x (cdr lst) (append accumulatedList (list (car lst))))])])
  )

; Returns only the permutations in a list of permutations that begin
; with the specified element
(define (startsWith x permutationsList)
  ; We filter each permutation of the permutationsList by the lambda expression
  ; in which we're producing a predicate for whether or not the specified starting
  ; element x is equal to the first element of each permutation, y
  (filter (lambda (y) (eqv? x (car y))) permutationsList)
  )